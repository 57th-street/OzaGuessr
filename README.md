# 概要
対戦相手とクイズの得点を争うゲーム（お互いの忙しさの都合上、今は開発一時停止中）。

# 工夫した点

### **アーキテクチャ構成**

保守性を高めるために、アプリケーションをコントローラ層、サービス層、リポジトリ層の3つのレイヤーに分割して構築した。
加えてルータ層も設け、ルーティング周りの設定をそこに移すことで、main関数の記述をシンプルにした。

### **インターフェースでレイヤー間の結合を疎にする**

コントローラ層→サービス層間の結合を例にとってやってみたことを説明してみる。
まずコントローラ層に、コンストラクタを用意する。
そのコンストラクタは、コントローラ層が依存するサービス層の関数のインターフェース（メソッド名、引数の型、返り値の型）から成る構造体を返すものとする。
コントローラ層の関数をこのコンストラクタで生成された構造体に紐づくメソッドとして再定義する。
実際に利用する際は、main関数から具体的な構造体を注入して実行させる。

このような構成にすることで以下のメリットが得られた。

- 依存先が変更することになっても、構成さえ変わらなければ簡単に差し替えが可能
- テスト時には依存先をモックに差し替えられる
- 依存先の変更の影響を受けない

### **インターフェースを分離する**

インターフェースが無駄に大きいと、それだけ要求されるものも多くなり、柔軟性が低下する。
そのため、役割ごとにインターフェースを分離し、抽象度が高まるよう努力した。

### **エラー処理の工夫**

- エラーチェーンを利用して、処理の途中で起こったエラーも余すことなく伝えるようにする
- errors.Is関数を用いて、エラーがラップされている場合でも正しくエラーを比較できるようにする
- エラーコード、メッセージ、エラー詳細から成る独自エラー型を定義し、開発者と利用者でエラー内容を出し分けたり、エラーコードに応じてステータスコードを決定できるようにする
- エラーハンドリング処理は一箇所にまとめ、エラー周りの処理が各所に点在するのを避ける

### **単体テスト**

モックやテストデータを作り、実行時にはそれらを注入してテストした。
依存先の挙動に影響を受けることなく、そして複数のケースを柔軟にテストすることができた。

### **jwtを利用したトークンベース認証**

トークンの発行に関しては、ログイン成功後にユーザーIDを元にトークンを作成し、それをヘッダのAuthorizationに加えレスポンスとして返すようにした。
トークンの検証に関しては、認証が必要なリソースへアクセスする度に自作の認証ミドルウェア内でトークンの検証を行い、認証に成功したら次のハンドラへ進ませるようにした。
